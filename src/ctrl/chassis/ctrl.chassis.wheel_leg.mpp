module;

#include <eigen3/Eigen/Eigen>

export module robo:ctrl.chassis.wheel_leg;

import std;
import :dev;
import :ctrl.basic;
import :ctrl.leg;
import :spt;

export namespace robo::ctrl::chassis {
template <ctrl::leg Leg, dev::motor M>
class WheelLeg;

template <ctrl::leg Leg, dev::motor M>
class WheelLegInfo {
    using ctrl_type = WheelLeg<Leg, M>;

    spt::task_context::periodic::info context;

    Leg leg_left;
    Leg leg_right;
    M wheel_left;
    M wheel_right;

    float f_gravity;
    ctrl::pid::param pid_l;
};

template <ctrl::leg Leg, dev::motor M>
class WheelLeg final :
    public spt::immovable_base, 
    public spt::not_copyable_base {
private:
    const WheelLegInfo<Leg, M>& info_;

    bool started_ { false };

    const float f_gravity { info_.f_gravity };
    const std::array<float, 8> trans_arr { 
        1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f
    };
    const Eigen::Map<const Eigen::Matrix<float, 4, 2>> trans { trans_arr.data() };
    ctrl::pid pid_l { info_.pid_l };
    
public:
    Leg::ctrl_type leg_left  { info_.leg_left };
    Leg::ctrl_type leg_right { info_.leg_right };
    M::dev_type    wheel_left   { info_.wheel_left };
    M::dev_type    wheel_right  { info_.wheel_right };

    explicit WheelLeg(const WheelLeg<Leg, M>& info) : 
        info_ { info } {
        spt::task_context::add_task(info_.context, [this] { ctrl_loop(); });
    }

    void run() { started_ = true; };
    void init() {}

private:
    void ctrl_loop() {
        if (started_) {
            
        }
    }
};
} // namespace robo::ctrl::chassis

