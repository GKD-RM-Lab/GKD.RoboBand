module;

#include <eigen3/Eigen/Eigen>

export module robo:ctrl.chassis.wheel_leg;

import std;
import :dev;
import :ctrl.basic;
import :ctrl.leg;
import :spt;

export namespace robo::ctrl::chassis {
template <dev::imu Imu, ctrl::leg Leg, dev::motor M>
class WheelLeg;

template <dev::imu Imu, ctrl::leg Leg, dev::motor M>
struct WheelLegInfo {
    using ctrl_type = WheelLeg<Imu, Leg, M>;
#ifdef USE_WEBOTS
    static constexpr bool use_webots = [] {
        bool leg = Leg::use_webots;
        bool m = std::same_as<M, motor::Webots::Info>;
        if (leg and m) return true;
        if (not leg and not m) return false;
        throw std::logic_error{ "mixing webots types and real types." };
    }();

    spt::task_context::periodic::info context { spt::task_context::periodic::info::webots() };
    std::chrono::nanoseconds ctrl_period;
    std::chrono::nanoseconds motor_ctrl_interval { std::chrono::nanoseconds::max() };
#else
    spt::task_context::periodic::info context;
    std::chrono::nanoseconds ctrl_period;
    std::chrono::nanoseconds motor_ctrl_interval;
#endif

    Imu imu;
    Leg leg_left;
    Leg leg_right;
    M wheel_left;
    M wheel_right;

    struct {
        float f_gravity;
        float wheel_radius;
    } constant;

    struct {
        struct {
            float min;
            float max;
        } height_set;
        struct {
            float stop_dead_zone;
        } speed;
        struct {
            float max;
            float delta_max;
            float dead_zone;
        } speed_set;
        struct {
            float max;
            float delta_max;
            float dead_zone;
        } yaw_err_set;
        float s_ref_max;
        float phi_err_max;
        float theta_l_ref_max;
        float theta_b_ref_max;
    } limit;
    
    struct {
        std::array<float, 40> K;
        ctrl::pid::param pid_height;
        ctrl::pid::param pid_psi;
    } param;
};

template <dev::imu Imu, ctrl::leg Leg, dev::motor M>
class WheelLeg final :
    public spt::immovable_base, 
    public spt::not_copyable_base,
    private WheelLegInfo<Imu, Leg, M> {
public: 
    using Info = WheelLegInfo<Imu, Leg, M>;

private:
    bool started_ { false };
    bool emergency_stopped { false };

    ctrl::ramp speed_set { 0.0f, this->limit.speed_set.max, this->limit.speed_set.delta_max };
    ctrl::ramp yaw_err_set { 0.0f, this->limit.yaw_err_set.max, this->limit.yaw_err_set.delta_max };
    float height_set { this->limit.height_set.min };

    float s_offset {};
    float phi_offset {};
    Eigen::Vector<float, 10> state_ref {};
    float height_ref {};

    const Eigen::Matrix<float, 2, 4, Eigen::RowMajor> trans { std::array{
        1.0f, 1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f, 1.0f
    }.data() };
    const Eigen::Matrix<float, 4, 10, Eigen::RowMajor> K { this->param.K.data() };
    ctrl::pid pid_height { this->param.pid_height };
    ctrl::pid pid_psi { this->param.pid_psi };

public:
    Imu::dev_type  imu         { Info::imu };
    Leg::ctrl_type leg_left    { Info::leg_left };
    Leg::ctrl_type leg_right   { Info::leg_right };
    M::dev_type    wheel_left  { Info::wheel_left };
    M::dev_type    wheel_right { Info::wheel_right };

public:
    explicit WheelLeg(const Info& info) : 
        Info { info } {
#ifdef USE_WEBOTS
        if (not this->context.test(Info::use_webots)) {
            throw std::logic_error{ "wrong context type." };
        }
#endif
        spt::task_context::add_task(this->context, this->ctrl_period, [this] { ctrl_loop(); });
    }

    void run() { started_ = true; };
#ifdef USE_WEBOTS
    void init() requires Info::use_webots {
        while (imu.offline());
        s_offset = (wheel_left_ground_angle().first + wheel_right_ground_angle().first) * this->constant.wheel_radius / 2.0f;
        phi_offset = imu.angle(imu::axis::yaw);
        leg_left.motor1.setAngle(3.447f);
        leg_left.motor2.setAngle(3.447f);
        leg_right.motor1.setAngle(3.447f);
        leg_right.motor2.setAngle(3.447f);
    }
#endif

private:
    auto wheel_left_ground_angle() -> std::pair<float, float> {
        float dir = Info::leg_left.forward_installation ? 1.0f : -1.0f;
        return {
            wheel_left.angle() - leg_left.wheel_angle_offset().first + dir * imu.angle(imu::axis::pitch),
            wheel_left.speed() - leg_left.wheel_angle_offset().second + dir * imu.gyro(imu::axis::pitch),
        };
    }
    auto wheel_right_ground_angle() -> std::pair<float, float> {
        float dir = Info::leg_right.forward_installation ? 1.0f : -1.0f;
        return {
            wheel_right.angle() - leg_right.wheel_angle_offset().first + dir * imu.angle(imu::axis::pitch),
            wheel_right.speed() - leg_right.wheel_angle_offset().second + dir * imu.gyro(imu::axis::pitch),
        };
    }

    void state_update() {
        leg_left.update();
        leg_right.update();
    
        float s = (wheel_left_ground_angle().first + wheel_right_ground_angle().first) * this->constant.wheel_radius / 2.0f;
        float dot_s = (wheel_left_ground_angle().second + wheel_right_ground_angle().second) * this->constant.wheel_radius / 2.0f;
        if (std::abs(speed_set) > this->limit.speed_set.dead_zone or std::abs(dot_s) > this->limit.speed.stop_dead_zone) {
            s_offset = s;
        }
        s = s - s_offset;
        float phi = imu.angle(imu::axis::yaw);
        if (yaw_err_set != 0.0f) {
            phi_offset = phi;
        }
        phi = std::remainder(phi - phi_offset, 2.0f * std::numbers::pi_v<float>);
        float dot_phi = imu.gyro(imu::axis::yaw);
        float theta_b = imu.angle(imu::axis::pitch);
        float dot_theta_b = imu.gyro(imu::axis::pitch);
        float theta_l_1 = leg_left.angle().first + theta_b;
        float theta_l_2 = leg_right.angle().first + theta_b;
        float dot_theta_l_1 = leg_left.angle().second + dot_theta_b;
        float dot_theta_l_2 = leg_right.angle().second + dot_theta_b;

        // TODO remove ?
        math::abs_limit(theta_l_1, this->limit.theta_l_ref_max);
        math::abs_limit(theta_l_2, this->limit.theta_l_ref_max);
        math::abs_limit(theta_b, this->limit.theta_b_ref_max);

        state_ref << s, dot_s, phi, dot_phi, theta_l_1, dot_theta_l_1, theta_l_2, dot_theta_l_2, theta_b, dot_theta_b;
        height_ref = 0.5f * (leg_left.length().first * std::cos(theta_l_1) + leg_right.length().first * std::cos(theta_l_2));
    }

    void ctrl_loop() {
        if (not started_) return;
            
        // TODO offline test
        state_update();

        Eigen::Vector<float, 10> state_set {};
        state_set.setZero();
        state_set(1) = speed_set;
        state_set(2) = state_ref(2) + yaw_err_set;
        Eigen::Vector<float, 10> state_err = state_set - state_ref;

        Eigen::Vector<float, 4> ctrl_vec = K * state_err;
        // TODO limit joint torque (ctrl_vec(2, 3))

        float f_inertial {}; // TODO
        float f_l = pid_height(height_set, height_ref);
        float f_psi = pid_psi(0.0f, imu.angle(imu::axis::roll));

        Eigen::Vector<float, 4> f_ctrl { f_psi, f_l, this->constant.f_gravity, f_inertial };
        Eigen::Vector<float, 2> f_n = trans * f_ctrl;

        if (emergency_stopped) {
            f_n.setZero();
            ctrl_vec.setZero();
        }

#ifdef USE_WEBOTS
        if constexpr (Info::use_webots) {
            wheel_left.setTorque(ctrl_vec(0));
            wheel_right.setTorque(ctrl_vec(1));
            leg_left.setForce(f_n(0), ctrl_vec(2));
            leg_right.setForce(f_n(1), ctrl_vec(3));
        } else {
#endif
            auto [f1_l, f2_l] = leg_left.calcForce(f_n(0), ctrl_vec(2));
            auto [f1_r, f2_r] = leg_right.calcForce(f_n(1), ctrl_vec(3));
            wheel_left.setTorque(ctrl_vec(0));
            leg_left.motor1.setTorque(f1_l);
            leg_right.motor1.setTorque(f1_r);
            std::this_thread::sleep_for(this->motor_ctrl_interval);
            wheel_right.setTorque(ctrl_vec(1));
            leg_left.motor2.setTorque(f2_l);
            leg_right.motor2.setTorque(f2_r);
#ifdef USE_WEBOTS
        }
#endif
    }
    
public:
    void emergencyStop() { emergency_stopped = true; }
    void setSpeed(float val) {
        speed_set(val);
        if (std::abs(speed_set) < this->limit.speed_set.dead_zone) {
            speed_set.get() = 0.0f;
        }
    }
    void setYawErr(float val) {
    }
    void adjustHeight(float val) {
        height_set = std::clamp(height_set + val, this->limit.height_set.min, this->limit.height_set.max);
        height_set = 0.2f; // TODO 
    }
};
} // namespace robo::ctrl::chassis

