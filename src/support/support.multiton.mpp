export module robo:support.multiton;

import std;
import :support.misc;

export namespace robo {
namespace spt {
///////////////////////////////////////////
// concepts:
//     owner (impl) : info() info_type                     
//     info         : key()  key_type owner_type 
//     multiton     : get()  key_type owner_type info_type
// usage:
//     multiton::get() -> owner
//     owner.info()    -> info
//     info.key()      -> key
//     info.desc()     -> description
///////////////////////////////////////////
template <typename T>
concept info =
    requires(T t) {
        typename T::key_type;
        typename T::owner_type;
        { t.key() } -> std::same_as<typename T::key_type>;
        { t.desc() } -> std::same_as<std::string>;
    };

template <typename T>
concept owner =
    spt::immovable<T> and
    spt::not_copyable<T> and
    info<typename T::info_type> and
    requires(T t) {
        { t.info() } -> std::same_as<const typename T::info_type&>;
    };

template <info T>
struct multiton {
    using info_type = T;
    using key_type = typename T::key_type;
    using owner_type = typename T::owner_type;
    static_assert(std::same_as<info_type, typename owner_type::info_type>);

    inline static std::mutex mutex_;
    inline static std::unordered_map<key_type, std::unique_ptr<owner_type>> instances {};

    multiton() = default;
    ~multiton() = default;
    multiton(const multiton&) = delete;
    multiton& operator=(const multiton&) = delete;
    multiton(multiton&&) = delete;
    multiton& operator=(multiton&&) = delete;

    [[nodiscard]]
    static auto get(const info_type& info) -> owner_type& {
        std::lock_guard<std::mutex> lock { mutex_ };
        auto it = instances.find(info.key());
        if (it != instances.end()) {
            return *it->second;
        }

        auto instance = std::make_unique<owner_type>(info);
        owner_type& ret = *instance;
        instances.emplace(info.key(), std::move(instance));
        return ret;
    };
};
} // namespace spt
} // namespace robo

