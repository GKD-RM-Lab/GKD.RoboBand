export module robo:io.adaptor;

import std;
import :support;
import :io.base;

export namespace robo {
namespace io {
template <typename T>
concept adaptor =
    std::constructible_from<T, typename T::key_type> and
    std::convertible_to<T, typename T::key_type> and
    requires() {
        { std::hash<typename T::key_type>{}(std::declval<typename T::key_type>()) }
            -> std::convertible_to<std::size_t>;
        { T::get_key(std::declval<std::span<const std::byte>>()) }
            -> std::same_as<std::optional<typename T::key_type>>;
        { T::label() } -> std::same_as<std::string>;
    };

namespace detail {
template <adaptor Adaptor, bare_io_info Io>
class AdaptorImpl {
public:
    struct Info : Io {
        using owner_type = AdaptorImpl;
        auto label() const {
            return std::format("{} (with adaptor {})", Io::label(), Adaptor::label());
        }
    };
    using info_type = Info;

private:
    const Info info_;
    std::unordered_map<typename Adaptor::key_type, std::function<void()>> callbacks_;

public:
    AdaptorImpl(const Info& info) : info_ { info } {
        io::register_callback(static_cast<const Io&>(info), [this] { callback(); });      
    }

    [[nodiscard]]
    auto info() const -> const Info& { return info_; };
    void register_callback(typename Adaptor::key_type key, spt::invocable_r<void> auto&& func) {
        auto [_, success] = callbacks_.emplace(key, std::forward<decltype(func)>(func));
        if (not success) {
            throw std::logic_error{ 
                "repeatedly register callback with a same key to " + info_.label()
            };
        }
    }

private:
    void callback() {
        auto rx_bytes = spt::multiton<Io>::get(info_).get_rx_bytes();
        auto ret = Adaptor::get_key(rx_bytes);
        if (not ret.has_value()) {
            // TODO log
            return;
        }
        if (not callbacks_.contains(ret.value())) {
            // TODO log
            return;
        }
        callbacks_[ret.value()]();
    }
};
} // namespace detail

template <adaptor Adaptor>
void register_callback(bare_io_info auto& io_info, auto key, spt::invocable_r<void> auto&& func) {
    using io_info_type = std::remove_cvref_t<decltype(io_info)>;
    using adaptor_key_type = typename Adaptor::key_type;
    using adaptor_info_type = typename detail::AdaptorImpl<Adaptor, io_info_type>::info_type;
    static_assert(std::convertible_to<decltype(key), adaptor_key_type>);
    spt::multiton<adaptor_info_type>::get(static_cast<const adaptor_info_type&>(io_info))
        .register_callback(key, std::forward<decltype(func)>(func));
}
template <adaptor Adaptor>
void register_callback(bare_io_impl auto& io_impl, auto key, spt::invocable_r<void> auto&& func) {
    register_callback<Adaptor>(io_impl.info(), key, std::forward<decltype(func)>(func));
}

void register_callback(bare_io_info auto& io_info, adaptor auto adaptor, spt::invocable_r<void> auto&& func) {
    register_callback<decltype(adaptor)>(io_info, adaptor, std::forward<decltype(func)>(func));
}
void register_callback(bare_io_impl auto& io_impl, adaptor auto adaptor, spt::invocable_r<void> auto&& func) {
    register_callback<decltype(adaptor)>(io_impl, adaptor, std::forward<decltype(func)>(func));
}

template <std::size_t N = 1> requires (N > 0)
struct prefix_key {
    using key_type = std::array<std::byte, N>;
    static auto get_key(std::span<const std::byte> bytes) -> std::optional<key_type> {
        if (bytes.size() <= N) return std::nullopt;
        key_type key;
        std::ranges::copy(bytes.first<N>(), key.begin());
        return { key };
    }
    static auto label() { 
        return std::format("prefix_key<{}>", N);
    }

    key_type key;
    prefix_key(const key_type key) : key { key } {}    
    operator key_type () const { return key; }
};
template <std::size_t N = 1> requires (N > 0)
prefix_key(std::array<std::byte, N>) -> prefix_key<N>;

template <>
struct prefix_key<1> {
    using key_type = std::byte;
    static auto get_key(std::span<const std::byte> bytes) -> std::optional<key_type> {
        if (bytes.size() <= 1) return std::nullopt;
        return { bytes[0] };
    }
    static auto label() -> std::string { return "prefix_key<1>"; }

    key_type key;
    prefix_key(const key_type key) : key { key } {}    
    operator key_type () const { return key; }
};
prefix_key(std::byte) -> prefix_key<1>;

} // namespace io
} // namespace robo

export template<std::size_t N>
struct std::hash<std::array<std::byte, N>>
{
    std::size_t operator()(const std::array<std::byte, N>& bytes) const noexcept
    {
        std::string_view s { std::bit_cast<char*>(bytes.data()), N };
        return std::hash<std::string_view>{}(s);
    }
};

