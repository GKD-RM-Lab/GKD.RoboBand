export module robo:io.adaptor;

import std;
import :support;
import :io.base;

export namespace robo {
namespace io {
template <typename T>
concept adaptor =
    requires() {
        { std::hash<typename T::key_type>{}(std::declval<typename T::key_type>()) }
            -> std::convertible_to<std::size_t>;
        { T::get_key(std::declval<std::span<const std::byte>>()) }
            -> std::same_as<std::optional<typename T::key_type>>;
        { T::desc() } -> std::same_as<std::string>;
    };

namespace detail {
template <adaptor Adaptor, bare_io_info Io>
class AdaptorImpl {
public:
    struct Info : Io {
        using owner_type = AdaptorImpl;
        auto desc() const {
            return std::format("{} (with adaptor {})", Io::desc(), Adaptor::desc());
        }
    };
    using info_type = Info;

private:
    const Info info_;
    std::unordered_map<typename Adaptor::key_type, std::function<void(std::span<const std::byte>)>> callbacks_;

public:
    AdaptorImpl(const Info& info) : info_ { info } {
        io::register_callback(static_cast<const Io&>(info), [this](auto bytes) { this->callback(bytes); });      
    }

    [[nodiscard]]
    auto info() const -> const Info& { return info_; };
    void register_callback(typename Adaptor::key_type key, io_callback auto&& func) {
        auto [_, success] = callbacks_.emplace(key, std::forward<decltype(func)>(func));
        if (not success) {
            throw std::logic_error{ 
                "repeatedly register callback with a same key to " + info_.desc()
            };
        }
    }

private:
    void callback(auto rx_bytes) {
        auto ret = Adaptor::get_key(rx_bytes);
        if (not ret.has_value() or not callbacks_.contains(ret.value())) {
            io::error_handler(spt::multiton<Io>::get(info_), io::error::invalid_data, info_.desc());
            return;
        }
        callbacks_[ret.value()](rx_bytes);
    }
};
} // namespace detail

template <adaptor Adaptor>
void register_callback(bare_io_info auto& io_info, auto key, io_callback auto&& func) {
    using io_info_type = std::remove_cvref_t<decltype(io_info)>;
    using adaptor_key_type = typename Adaptor::key_type;
    using adaptor_info_type = typename detail::AdaptorImpl<Adaptor, io_info_type>::info_type;
    static_assert(std::convertible_to<decltype(key), adaptor_key_type>);
    spt::multiton<adaptor_info_type>::get(static_cast<const adaptor_info_type&>(io_info))
        .register_callback(key, std::forward<decltype(func)>(func));
}
template <adaptor Adaptor>
void register_callback(bare_io_impl auto& io_impl, auto key, io_callback auto&& func) {
    register_callback<Adaptor>(io_impl.info(), key, std::forward<decltype(func)>(func));
}

template <std::size_t N = 1> requires (N > 0)
struct prefix_key {
    using key_type = std::array<std::byte, N>;
    static auto get_key(std::span<const std::byte> bytes) -> std::optional<key_type> {
        if (bytes.size() <= N) return std::nullopt;
        key_type key;
        std::ranges::copy(bytes.first<N>(), key.begin());
        return { key };
    }
    static constexpr auto desc() { 
        return std::format("prefix_key<{}>", N);
    }
};

template <>
struct prefix_key<1> {
    using key_type = std::byte;
    static auto get_key(std::span<const std::byte> bytes) -> std::optional<key_type> {
        if (bytes.size() <= 1) return std::nullopt;
        return { bytes[0] };
    }
    static constexpr auto desc() -> std::string { return "prefix_key<1>"; }
};
} // namespace io
} // namespace robo

export template<std::size_t N> requires (N > 1)
struct std::hash<std::array<std::byte, N>>
{
    std::size_t operator()(const std::array<std::byte, N>& bytes) const noexcept
    {
        std::string_view s { std::bit_cast<char*>(bytes.data()), N };
        return std::hash<std::string_view>{}(s);
    }
};

