module;

#include <unistd.h>
#include <cerrno>
#include <sys/poll.h>

export module robo:io.base;

import std;
import :support;

export namespace robo {
namespace io {
enum class state {
    offline,
    error,
    working,
};

enum class error {
    offline,
    invalid_data,
    callback_unregistered,
    read_failed,
    write_failed,
};

void default_error_handler(const io::error err, const std::string& io_desc) {
    switch (err) {
        using enum io::error;
        case error::offline:
            break;
        case error::invalid_data:
            break;
        case error::callback_unregistered:
            throw std::logic_error{ 
                "no callback registered to " + io_desc
            };
        case error::read_failed:
            throw std::system_error { errno, std::system_category(), 
                "read failed on " + io_desc
            };
        case error::write_failed: break;
            throw std::system_error { errno, std::system_category(), 
                "write failed on " + io_desc
            };
    }
}
void allow_no_callback(const io::error err, const std::string& io_desc) {
    if (err != robo::io::error::callback_unregistered) {
        robo::io::default_error_handler(err, io_desc);
    }
};

template <typename T>
concept io_impl_base =
    spt::owner<T> and
    requires(T t) {
        { t.send(std::declval<std::span<const std::byte>>()) } -> std::same_as<void>;
        { t.get_rx_bytes() } -> std::same_as<std::span<const std::byte>>;
        { t.error_handler(std::declval<const io::error>(), std::declval<const std::string&>()) }
            -> std::same_as<void>;
        { t.register_error_handler([](const io::error, const std::string&) {}) }
            -> std::same_as<void>;
    };
template <typename T>
concept bare_io_impl =
    io_impl_base<T> and
    requires(T t) {
        { t.register_callback([] {}) } -> std::same_as<void>;
    };
template <typename T>
concept keyed_io_impl =
    io_impl_base<T> and
    requires(T t) {
        { t.register_callback(std::declval<typename T::io_key_type>(), [] {}) }
            -> std::same_as<void>;
    };
template <typename T>
concept io_impl =
    bare_io_impl<T> or keyed_io_impl<T>;

template <typename T>
concept bare_io_info =
    spt::info<T> and
    bare_io_impl<typename T::owner_type>;
template <typename T>
concept keyed_io_info =
    spt::info<T> and
    keyed_io_impl<typename T::owner_type>;
template <typename T>
concept io_info =
    bare_io_info<T> or keyed_io_info<T>;

void send(io_impl auto& io_impl, auto&&... args) {
    io_impl.send(std::forward<decltype(args)>(args)...);
}
void send(io_info auto& io_info, auto&&... args) {
    using io_info_type = std::remove_cvref_t<decltype(io_info)>;
    spt::multiton<io_info_type>::get(io_info).send(std::forward<decltype(args)>(args)...);
}

auto get_rx_bytes(io_impl auto& io_impl) {
    return io_impl.get_rx_bytes();
}
auto get_rx_bytes(io_info auto& io_info) {
    using io_info_type = std::remove_cvref_t<decltype(io_info)>;
    return spt::multiton<io_info_type>::get(io_info).get_rx_bytes();
}

void register_callback(io_impl auto& io_impl, auto&&... args) {
    io_impl.register_callback(std::forward<decltype(args)>(args)...);
}
void register_callback(io_info auto& io_info, auto&&... args) {
    using io_info_type = std::remove_cvref_t<decltype(io_info)>;
    register_callback(spt::multiton<io_info_type>::get(io_info), std::forward<decltype(args)>(args)...);
}

void register_error_handler(io_impl auto& io_impl, auto&&... args) {
    io_impl.register_error_handler(std::forward<decltype(args)>(args)...);
}
void register_error_handler(io_info auto& io_info, auto&&... args) {
    using io_info_type = std::remove_cvref_t<decltype(io_info)>;
    register_error_handler(spt::multiton<io_info_type>::get(io_info), std::forward<decltype(args)>(args)...);
}

void error_handler(io_impl auto& io_impl, auto&&... args) {
    io_impl.error_handler(std::forward<decltype(args)>(args)...);
}
void error_handler(io_info auto& io_info, auto&&... args) {
    using io_info_type = std::remove_cvref_t<decltype(io_info)>;
    register_error_handler(spt::multiton<io_info_type>::get(io_info), std::forward<decltype(args)>(args)...);
}

class Fd {
private:
    static constexpr int empty_fd { -1 };
    int fd_ { empty_fd };

public:
    Fd() = default;
    explicit Fd(int fd)
        : fd_{ fd } {}
    ~Fd() {
        close();
    }

    Fd(Fd &&other) noexcept
        : fd_{ std::exchange(other.fd_, empty_fd) } {}
    Fd& operator=(Fd &&other) noexcept {
        close();
        fd_ = std::exchange(other.fd_, empty_fd);
        return *this;
    }

    Fd(const Fd &other) noexcept = delete;
    Fd& operator=(const Fd &other) noexcept = delete;

    [[nodiscard]]
    bool is_valid() const { return fd_ >= 0; }
    [[nodiscard]]
    auto get() const -> const int& { return fd_; }
    [[nodiscard]]
    operator int() const { return fd_; }

    void close() {
        if (not is_valid()) return;
        int fd_temp = std::exchange(fd_, empty_fd);
        auto ret = ::close(fd_temp);
        if (ret != 0) {
            throw std::system_error{ errno, std::system_category(),
                std::format("close fd {} failed", fd_)
            };
        }
    }

    pollfd make_pollfd(short events = 0) {
        return { fd_, events, 0 };
    }
};
} // namespace io
} // namespace robo

