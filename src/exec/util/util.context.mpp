export module exec:util.context;

import std;
import :support.misc;
import :support.tag;
import :support.concepts;
import :support.typelist; 

export namespace exec {
///////////////////////////////////////////
// run_loop
///////////////////////////////////////////
struct run_loop : detail::immovable {
    struct task : detail::immovable {
        task* next { this };
        virtual void execute() noexcept {}
    };

    // FIFO linked list
    task head_ {};
    task* tail_ { &head_ };

    bool finishing_ { false };
    std::mutex mtx_ {};
    std::condition_variable cv_ {};

    void push_back(task* op) {
        std::unique_lock lk(mtx_);
        op->next = &head_;
        tail_ = tail_->next = op;
        cv_.notify_one();
    }
    task* pop_front() {
        std::unique_lock lk(mtx_);
        cv_.wait(lk, [this] { return (head_.next != &head_) or finishing_; });
        if (head_.next == &head_) {
            return nullptr;
        }
        return std::exchange(head_.next, head_.next->next);
    }
    void finish() {
        std::unique_lock lk(mtx_);
        finishing_ = true;
        cv_.notify_all();
    }

    void run() {
        while (task* op = pop_front()) {
            op->execute();
        }
    }

    struct sender {
        template <template <typename...> class Tuple, template <typename...> class Variant>
        using value_types = Variant<Tuple<>>;
        template <template <typename...> class Variant>
        using error_types = Variant<std::exception_ptr>;
        // TODO
        static const constexpr bool sends_done = true;

        run_loop& loop_;

        template <class R>
        struct operation : task {
            [[no_unique_address]] R rcvr_;
            run_loop& loop_;

            template <typename Rcvr>
            operation(Rcvr&& rcvr, run_loop& loop) :
                rcvr_(std::forward<Rcvr>(rcvr)), loop_(loop) {}

            void execute() noexcept override final {
                try {
                    set_value(std::move(rcvr_));
                } catch (...) {
                    set_error(std::move(rcvr_), std::current_exception());
                }
            }

            friend void tag_invoke(start_tag, operation& op_self) noexcept {
                try {
                    op_self.loop_.push_back(&op_self);
                } catch (...) {
                    set_error(std::move(op_self.rcvr_), std::current_exception());
                }
            }
        };

        template <receiver R>
        friend auto tag_invoke(connect_tag, const sender& sndr_self, R&& rcvr)
            -> operation<std::remove_cvref_t<R>> {
            return { std::forward<R>(rcvr), sndr_self.loop_ };
        }
    };

    struct scheduler {
        run_loop& loop_;
        friend auto tag_invoke(schedule_tag, const scheduler& sched_self) noexcept -> sender {
            return { sched_self.loop_ };
        }
    };

    auto get_scheduler() -> scheduler {
        return { *this };
    }
};

///////////////////////////////////////////
// thread_context execution context
///////////////////////////////////////////
class thread_context : run_loop {
    std::jthread th { [this] { run(); } };

public:
    using run_loop::finish;
    using run_loop::get_scheduler;

    ~thread_context() {
        finish();
    }
};
} // namespace exec
