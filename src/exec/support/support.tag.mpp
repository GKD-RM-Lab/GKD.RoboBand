export module exec:support.tag;

import std;

export namespace exec {
namespace detail {
    struct tag_invoke_test {
        template <typename Tag, typename... Args>
        constexpr auto operator()(Tag tag, Args&&... args) const
            noexcept(noexcept(tag_invoke(static_cast<Tag&&>(tag), static_cast<Args&&>(args)...)))
            -> decltype(tag_invoke(static_cast<Tag&&>(tag), static_cast<Args&&>(args)...)) {
            return tag_invoke(static_cast<Tag&&>(tag), static_cast<Args&&>(args)...);
        }
    };

template <typename Tag, typename... Args>
concept tag_invocable = std::invocable<tag_invoke_test, Tag, Args...>;
template <typename Tag, typename... Args>
concept nothrow_tag_invocable = std::is_nothrow_invocable_v<tag_invoke_test, Tag, Args...>;
template <typename Tag, typename... Args>
using tag_invoke_result_t = std::invoke_result_t<tag_invoke_test, Tag, Args...>;
} // namespace detail

template <auto& Tag>
using tag_t = std::remove_cvref_t<decltype(Tag)>;

struct set_done_tag {
    template <typename R>
        requires detail::nothrow_tag_invocable<set_done_tag, R>
    auto operator()(R&& r) const noexcept
        -> detail::tag_invoke_result_t<set_done_tag, R> {
        return tag_invoke(set_done_tag {}, static_cast<R&&>(r));
    }
};
constexpr set_done_tag set_done {};

struct set_error_tag {
    template <typename R, typename E>
        requires detail::nothrow_tag_invocable<set_error_tag, R, E>
    auto operator()(R&& r, E&& e) const noexcept 
        -> detail::tag_invoke_result_t<set_error_tag, R, E> {
        return tag_invoke(set_error_tag {}, static_cast<R&&>(r), static_cast<E&&>(e));
    }
};
constexpr set_error_tag set_error {};

struct set_value_tag {
    template <typename R, typename... Ts>
        requires detail::tag_invocable<set_value_tag, R, Ts...>
    auto operator()(R&& r, Ts&&... vs) const noexcept(detail::nothrow_tag_invocable<set_value_tag, R, Ts...>)
        -> detail::tag_invoke_result_t<set_value_tag, R, Ts...> {
        return tag_invoke(set_value_tag {}, static_cast<R&&>(r), static_cast<Ts&&>(vs)...);
    }
};
constexpr set_value_tag set_value {};

struct connect_tag {
    template <typename S, typename R>
        requires detail::tag_invocable<connect_tag, S, R>
    auto operator()(S&& s, R&& r) const noexcept(detail::nothrow_tag_invocable<connect_tag, S, R>)
        -> detail::tag_invoke_result_t<connect_tag, S, R> {
        return tag_invoke(connect_tag {}, static_cast<S&&>(s), static_cast<R&&>(r));
    }
};
constexpr connect_tag connect {};

struct start_tag {
    template <typename O>
        requires detail::nothrow_tag_invocable<start_tag, O>
    auto operator()(O&& op) const noexcept 
        -> detail::tag_invoke_result_t<start_tag, O> {
        return tag_invoke(start_tag {}, static_cast<O&&>(op));
    }
};
constexpr start_tag start {};

struct schedule_tag {
    template <typename S>
        requires detail::nothrow_tag_invocable<schedule_tag, S>
    auto operator()(S&& sched) const noexcept 
        -> detail::tag_invoke_result_t<schedule_tag, S> {
        return tag_invoke(schedule_tag {}, static_cast<S&&>(sched));
    }
};
constexpr schedule_tag schedule {};
} // namespace exec

