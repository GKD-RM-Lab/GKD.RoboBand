export module exec:util;

import std;
import :util.tag;

export namespace exec {
namespace detail {
struct immoveable {
    immoveable() = default;
    immoveable(immoveable&&) = delete;
};
} // namespace detail

template <typename S, typename R>
using connect_result_t = decltype(connect(std::declval<S>(), std::declval<R>()));

template <typename R, typename E = std::exception_ptr>
concept receiver =
    std::move_constructible<std::remove_cvref_t<R>> &&
    std::constructible_from<std::remove_cvref_t<R>, R> &&
    requires(std::remove_cvref_t<R>&& t, E&& e) {
        { exec::set_done(std::move(t)) } noexcept;
        { exec::set_error(std::move(t), (E&&) e) } noexcept;
    };

template <typename R, typename... An>
concept receiver_of = receiver<R> && 
    requires(std::remove_cvref_t<R>&& t, An&&... an) {
        exec::set_value(std::move(t), (An&&)an...);
    };

template <typename S>
struct sender_traits {
    template <template <typename...> typename Tuple, template <typename...> typename Variant>
    using value_types = typename S::template value_types<Tuple, Variant>;
    template <template <typename...> typename Variant>
    using error_types = typename S::template error_types<Variant>;
    static constexpr bool sends_done = S::sends_done;
};

template <typename S>
concept sender = std::move_constructible<std::remove_cvref_t<S>> &&
    std::same_as<decltype(std::remove_cvref_t<S>::sends_done), const bool> &&
    requires {
        typename std::remove_cvref_t<S>::template value_types<std::tuple, std::variant>;
        typename std::remove_cvref_t<S>::template error_types<std::variant>;
    };

// TODO
template <typename S, typename E>
concept sender_in = true;

template <typename S, typename R>
concept sender_to = sender<S> && receiver<R> &&
    requires(S&& sndr, R&& rcvr) {
        connect(std::forward<S>(sndr), std::forward<R>(rcvr));
    };

} // namespace exec

