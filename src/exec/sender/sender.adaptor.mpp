export module exec:sender.adaptor;

import std;
import :support.misc;
import :support.core;
import :support.concepts;
import :support.typelist;

export namespace exec {
///////////////////////////////////////////
// exec::then(sender, func) -> sender
// sender | exec::then(func) -> sender
///////////////////////////////////////////
namespace detail {
template <receiver R, typename F>
struct then_receiver {
    [[no_unique_address]] R rcvr_out_;
    [[no_unique_address]] F func_;

    template <typename... Ts>
        requires std::is_invocable_v<F, Ts...>
    void set_value(then_receiver&&, Ts&&... vs) 
        noexcept(std::is_nothrow_invocable_v<F, Ts...>) {
        try {
            if constexpr (std::same_as<void, std::invoke_result_t<F, Ts...>>) {
                static_assert(receiver_of<R>);
                std::invoke(std::move(func_), std::forward<Ts>(vs)...);
                exec::set_value(std::move(rcvr_out_));
            } else {
                static_assert(receiver_of<R, std::invoke_result_t<F, Ts...>>);
                exec::set_value(std::move(rcvr_out_), std::invoke(std::move(func_), std::forward<Ts>(vs)...));
            }
        } catch (...) {
            exec::set_error(std::move(rcvr_out_), std::current_exception());
        }
    }
    template <typename E>
    void set_error(then_receiver&&, E&& e) noexcept {
        exec::set_error(std::move(rcvr_out_), std::forward<E>(e));
    }
    void set_done(then_receiver&&) noexcept {
        exec::set_done(std::move(rcvr_out_));
    }
};

template <receiver R, typename F>
then_receiver(R rcvr, F func) -> then_receiver<std::remove_cvref_t<R>, std::decay_t<F>>;

template <sender S, typename F>
struct then_sender {
    template <typename... Args>
    using result_t_tl = type_list<filter_void_t<std::invoke_result_t<F, Args...>>>;
    template<template<typename...> class Tuple, template<typename...> class Variant>
    using value_types = zip_apply<
        typename sender_traits<S>::template value_types<result_t_tl, type_set_of_tl_tl>, 
        Tuple, 
        Variant>;

    template<template<typename...> class Variant>
    using error_types = type_set_of_tl_tl<
        typename sender_traits<S>::template error_types<type_list>,
        type_list<std::exception_ptr>
     >::template apply<Variant>;
    static const constexpr bool sends_done = sender_traits<S>::sends_done;

    [[no_unique_address]] S sndr_in_;
    [[no_unique_address]] F func_;

    template <typename Self, receiver R>
        requires std::same_as<std::remove_cvref_t<Self>, then_sender>
    auto connect(Self&&, R&& rcvr) {
        return exec::connect(
            std::forward_like<Self>(sndr_in_), 
            then_receiver{
                std::forward<R>(rcvr),
                std::forward_like<Self>(func_)
            });
    }
};
} // namespace detail

template <sender S, typename F>
auto then(S&& sndr, F&& func) -> detail::then_sender<std::remove_cvref_t<S>, std::decay_t<F>> {
    return { std::forward<S>(sndr), std::forward<F>(func) };
}

namespace detail {
template <typename F>
struct then_closure {
    F func_;

    template <sender S, typename Self>
        requires std::same_as<std::remove_cvref_t<Self>, then_closure>
    friend auto operator|(S&& sndr, Self&& closure_self) -> detail::then_sender<std::remove_cvref_t<S>, F> {
        return then(std::forward<S>(sndr), std::move(closure_self.func_));
    }
};
} // namespace detail

template <typename F>
auto then(F&& func) -> detail::then_closure<std::decay_t<F>> {
    return { std::forward<F>(func) };
}
///////////////////////////////////////////
// schedule_from
///////////////////////////////////////////

} // namespace exec

