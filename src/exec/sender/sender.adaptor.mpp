export module exec:sender.adaptor;

import std;
import :support.misc;
import :support.tag;
import :support.concepts;
import :support.typelist;

export namespace exec {
///////////////////////////////////////////
// exec::then(sender, func) -> sender
// sender | exec::then(func) -> sender
///////////////////////////////////////////
namespace detail {
template <receiver R, typename F>
struct then_receiver {
    [[no_unique_address]] R rcvr_out_;
    [[no_unique_address]] F func_;

    template <typename... Ts>
        requires std::is_invocable_v<F, Ts...>
    friend void tag_invoke(set_value_tag, then_receiver&& rcvr_self, Ts&&... vs) 
        noexcept(std::is_nothrow_invocable_v<F, Ts...>) {
        try {
            if constexpr (std::same_as<void, std::invoke_result_t<F, Ts...>>) {
                static_assert(receiver_of<R>);
                std::invoke(std::move(rcvr_self.func_), std::forward<Ts>(vs)...);
                set_value(std::move(rcvr_self.rcvr_out_));
            } else {
                static_assert(receiver_of<R, std::invoke_result_t<F, Ts...>>);
                set_value(std::move(rcvr_self.rcvr_out_), std::invoke(std::move(rcvr_self.func_), std::forward<Ts>(vs)...));
            }
        } catch (...) {
            set_error(std::move(rcvr_self.rcvr_out_), std::current_exception());
        }
    }
    template <typename E>
    friend void tag_invoke(set_error_tag, then_receiver&& rcvr_self, E&& e) noexcept {
        set_error(std::move(rcvr_self.rcvr_out_), std::forward<E>(e));
    }
    friend void tag_invoke(set_done_tag, then_receiver&& rcvr_self) noexcept {
        set_done(std::move(rcvr_self.rcvr_out_));
    }
};

template <sender S, typename F>
struct then_sender {
    template <typename... Args>
    using result_t_tl = type_list<filter_void_t<std::invoke_result_t<F, Args...>>>;
    template<template<typename...> class Tuple, template<typename...> class Variant>
    using value_types = zip_apply<
        typename sender_traits<S>::template value_types<result_t_tl, type_set_of_tl_tl>, 
        Tuple, 
        Variant>;

    template<template<typename...> class Variant>
    using error_types = type_set_of_tl_tl<
        typename sender_traits<S>::template error_types<type_list>,
        type_list<std::exception_ptr>
     >::template apply<Variant>;
    static const constexpr bool sends_done = sender_traits<S>::sends_done;

    [[no_unique_address]] S sndr_in_;
    [[no_unique_address]] F func_;

    // template <typename Self, receiver R>
    //     requires std::same_as<std::remove_cvref_t<Self>, just_sender>
    // friend auto tag_invoke(connect_tag, Self&& sndr_self, R&& rcvr) -> operation<std::remove_cvref_t<R>> {
    //     return { {}, std::forward<Self>(sndr_self).values_, std::forward<R>(rcvr) };
    // }
    template <typename Self, receiver R>
        requires std::same_as<std::remove_cvref_t<Self>, then_sender>
    friend auto tag_invoke(connect_tag, Self&& sndr_self, R&& rcvr) 
        -> connect_result_t<S, then_receiver<std::remove_cvref_t<R>, std::decay_t<F>>> {
        return { connect(
            std::forward<Self>(sndr_self).sndr_in_, 
            then_receiver{
                std::forward<R>(rcvr),
                std::forward<Self>(sndr_self).func_
            }) };
    }
};
} // namespace detail

// TODO scheduler
template <sender S, typename F>
auto then(S&& sndr, F&& func) -> detail::then_sender<std::remove_cvref_t<S>, std::decay_t<F>> {
    return { std::forward<S>(sndr), std::forward<F>(func) };
}

namespace detail {
template <typename F>
struct then_closure {
    F func_;

    template <sender S, typename Self>
        requires std::same_as<std::remove_cvref_t<Self>, then_closure>
    friend auto operator|(S&& sndr, Self&& closure_self) -> detail::then_sender<std::remove_cvref_t<S>, F> {
        return then(std::forward<S>(sndr), std::move(closure_self.func_));
    }
};
} // namespace detail

template <typename F>
auto then(F&& func) -> detail::then_closure<std::decay_t<F>> {
    return { std::forward<F>(func) };
}
} // namespace exec

