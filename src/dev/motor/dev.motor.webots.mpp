module;

#include <webots/motor.h>
#include <webots/position_sensor.h>
#include <webots/robot.h>

export module robo:dev.motor.webots;

import std;
import :dev.motor.base;
import :io;
import :support;

export namespace robo {
namespace motor {
class Webots : public dev::Motor {
public:
    struct Info {
        using dev_type = Webots;

        std::string_view name;
        enum motor::dir dir;
    };

private:
    const Info& info_;
    ::WbDeviceTag motor_tag_;
    ::WbDeviceTag encoder_tag_;
    float angle_last_ {};
    float angle_offset_ {};

public:
    explicit Webots(const Info& info) :
        Motor { std::chrono::hours::max() },
        info_ { info },
        motor_tag_ { spt::webots(wb_robot_get_device, std::string{info.name}.c_str()) },
        encoder_tag_ { spt::webots(wb_motor_get_position_sensor, motor_tag_) } {
        spt::webots(wb_position_sensor_enable, encoder_tag_, static_cast<int>(spt::webots.basic_time_step));
        spt::webots.add_step_task([this] {
            float angle_temp = static_cast<float>(spt::webots(wb_position_sensor_get_value, encoder_tag_));
            angle_ = static_cast<float>(info_.dir) * angle_temp - angle_offset_;
            speed_ = (angle_ - angle_last_) / (spt::webots.basic_time_step * 0.001f);
            angle_last_ = angle_;
        });
    }

    void setAngelOffset(float offset) {
        angle_offset_ = offset;
    }
    void setAngel(float current_angle) {
        angle_offset_ = angle_ - current_angle;
    }
    void setTorque(float torque) {
        spt::webots(wb_motor_set_torque, motor_tag_, static_cast<double>(torque));
    }
};
static_assert(dev::motor<Webots::Info>);
} // namespace motor
} // namespace robo

